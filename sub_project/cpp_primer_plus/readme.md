# C++ Primer Plus 第六版

## 02 开始学习C++
- `main` 函数被**启动代码**调用， 而启动代码是编译器加上去的

## 03 处理数据
- `__a`, `_A`, `_a` 两个下划线, 下划线加大写字母, 下划线的名称都是保留给实现使用的

## 04 复合类型
- 指针的类型不是数字， 其+1增加的量是它指向的类型的**字节数**

## 05 循环和关系表达式

## 06 分支语句，逻辑运算符


## 07 函数
- C++ 函数不能返回数组， 但是可以返回数组指针， 结构体， 对象
- C++ 函数是按值传递参数， 所以将结构体作为参数时， 会复制一个副本， 当结构体太大时， 会影响性能

## 08 函数探幽
- 类的设计语义常常要求使用引用， 这也是新增这个特性的主要原因
- &是在声明引用变量时使用， 以及使用指针时
- *在声明指针时，以及解引用指针时都会用到
- 函数重载不区分引用参数和按值传参， 一般不区分 const 和 非const 参数（非const 可以传给 const）
- 重载的函数名称会被修饰成其他名字

## 09 内存模型和名称空间
- extern
- 静态类型
- 外部链接性和内部链接性
- 名称空间
- new 可表示：
  - 常规new运算符， 分配内存： `new String`
  - 定位new运算符， 分配内存到某个 buffer `char* buffer=new char[100]; String* p= new (buffer) String;`;

## 10 对象和类
- 每个对象的内部变量独占内存空间
- 相同类的不同对象的方法，共享同一组类方法

## 11 使用类
- 运算符重载
- 友元函数
- 自动类型转换和强制类型转换
  -  显示类型转换 `explicit`
  -  `operator int()` 转换成int

## 12 类和动态内存分配
- 复制构造函数
- 重载=
- 构造函数成员初始化方法

## 13 类继承
- 派生类的构造函数总是会调用一个基类的构造函数， 如果没有显式调用， 那么就会隐式调用默认的
- 公共派生
- 虚方法， 虚析构函数
  - 声明为虚方法，会创建一个虚函数表， 占用内存空间
- 编译器会默认生成的
  - 默认构造函数
  - 默认复制构造函数
  - 默认赋值运算符
- `const string& foo(const string& b) const;`
  - 返回类型中的 const 表示返回的引用类型不能被修改
  - 最右侧的 const 表示不会修改 this

## 14 代码重用
- 私有继承， 保护继承
- 多重继承
- 模版类
  - 模版类的实现应该包含在头文件中
  - 模板别名
  - 多模板参数
  - 模板类的具体化

## 15 友元、异常和其他
- 友元类是为了解决访问相关联的类的私有变量
  - 友元可以访问自己的私有字段
- 嵌套类
- 异常
  - logic_error
    - domain_error
    - out_of_bounds
    - invalid_argument
    - length_error
  - runtime_error
    - range_error
    - overflow_error
    - underflow_error
- RTTI 运行时类型识别
  - 只能用于包含虚函数的类
  - dynamic_cast
  - typeid 返回 type_info 类
- 类型转换
  - const_cast
  - static_cast
  - reinterpret_cast

## 16 string 和 标准模版库
- 智能指针
  - unique_ptr
  - shared_ptr 引用计数用
- 标准库
  - vector